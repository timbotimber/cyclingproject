{"ast":null,"code":"const Constants = require('./constants');\n\nmodule.exports = function render() {\n  const store = this;\n  const mapExists = store.ctx.map && store.ctx.map.getSource(Constants.sources.HOT) !== undefined;\n  if (!mapExists) return cleanup();\n  const mode = store.ctx.events.currentModeName();\n  store.ctx.ui.queueMapClasses({\n    mode\n  });\n  let newHotIds = [];\n  let newColdIds = [];\n\n  if (store.isDirty) {\n    newColdIds = store.getAllIds();\n  } else {\n    newHotIds = store.getChangedIds().filter(id => store.get(id) !== undefined);\n    newColdIds = store.sources.hot.filter(geojson => {\n      return geojson.properties.id && newHotIds.indexOf(geojson.properties.id) === -1 && store.get(geojson.properties.id) !== undefined;\n    }).map(geojson => geojson.properties.id);\n  }\n\n  store.sources.hot = [];\n  const lastColdCount = store.sources.cold.length;\n  store.sources.cold = store.isDirty ? [] : store.sources.cold.filter(geojson => {\n    const id = geojson.properties.id || geojson.properties.parent;\n    return newHotIds.indexOf(id) === -1;\n  });\n  const coldChanged = lastColdCount !== store.sources.cold.length || newColdIds.length > 0;\n  newHotIds.forEach(id => renderFeature(id, 'hot'));\n  newColdIds.forEach(id => renderFeature(id, 'cold'));\n\n  function renderFeature(id, source) {\n    const feature = store.get(id);\n    const featureInternal = feature.internal(mode);\n    store.ctx.events.currentModeRender(featureInternal, geojson => {\n      store.sources[source].push(geojson);\n    });\n  }\n\n  if (coldChanged) {\n    store.ctx.map.getSource(Constants.sources.COLD).setData({\n      type: Constants.geojsonTypes.FEATURE_COLLECTION,\n      features: store.sources.cold\n    });\n  }\n\n  store.ctx.map.getSource(Constants.sources.HOT).setData({\n    type: Constants.geojsonTypes.FEATURE_COLLECTION,\n    features: store.sources.hot\n  });\n\n  if (store._emitSelectionChange) {\n    store.ctx.map.fire(Constants.events.SELECTION_CHANGE, {\n      features: store.getSelected().map(feature => feature.toGeoJSON())\n    });\n    store._emitSelectionChange = false;\n  }\n\n  if (store._deletedFeaturesToEmit.length) {\n    const geojsonToEmit = store._deletedFeaturesToEmit.map(feature => feature.toGeoJSON());\n\n    store._deletedFeaturesToEmit = [];\n    store.ctx.map.fire(Constants.events.DELETE, {\n      features: geojsonToEmit\n    });\n  }\n\n  store.ctx.map.fire(Constants.events.RENDER, {});\n  cleanup();\n\n  function cleanup() {\n    store.isDirty = false;\n    store.clearChangedIds();\n  }\n};","map":{"version":3,"sources":["/home/jfrank/Ironhack/LastProject/cyclingproject/mapbox-react-tutorial/mapboxAndReact/node_modules/mapbox-gl-draw/src/render.js"],"names":["Constants","require","module","exports","render","store","mapExists","ctx","map","getSource","sources","HOT","undefined","cleanup","mode","events","currentModeName","ui","queueMapClasses","newHotIds","newColdIds","isDirty","getAllIds","getChangedIds","filter","id","get","hot","geojson","properties","indexOf","lastColdCount","cold","length","parent","coldChanged","forEach","renderFeature","source","feature","featureInternal","internal","currentModeRender","push","COLD","setData","type","geojsonTypes","FEATURE_COLLECTION","features","_emitSelectionChange","fire","SELECTION_CHANGE","getSelected","toGeoJSON","_deletedFeaturesToEmit","geojsonToEmit","DELETE","RENDER","clearChangedIds"],"mappings":"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","sourcesContent":["const Constants = require('./constants');\n\nmodule.exports = function render() {\n  const store = this;\n  const mapExists = store.ctx.map && store.ctx.map.getSource(Constants.sources.HOT) !== undefined;\n  if (!mapExists) return cleanup();\n\n  const mode = store.ctx.events.currentModeName();\n\n  store.ctx.ui.queueMapClasses({ mode });\n\n  let newHotIds = [];\n  let newColdIds = [];\n\n  if (store.isDirty) {\n    newColdIds = store.getAllIds();\n  } else {\n    newHotIds = store.getChangedIds().filter(id => store.get(id) !== undefined);\n    newColdIds = store.sources.hot.filter((geojson) => {\n      return geojson.properties.id && newHotIds.indexOf(geojson.properties.id) === -1 && store.get(geojson.properties.id) !== undefined;\n    }).map(geojson => geojson.properties.id);\n  }\n\n  store.sources.hot = [];\n  const lastColdCount = store.sources.cold.length;\n  store.sources.cold = store.isDirty ? [] : store.sources.cold.filter((geojson) => {\n    const id = geojson.properties.id || geojson.properties.parent;\n    return newHotIds.indexOf(id) === -1;\n  });\n\n  const coldChanged = lastColdCount !== store.sources.cold.length || newColdIds.length > 0;\n\n  newHotIds.forEach(id => renderFeature(id, 'hot'));\n  newColdIds.forEach(id => renderFeature(id, 'cold'));\n\n  function renderFeature(id, source) {\n    const feature = store.get(id);\n    const featureInternal = feature.internal(mode);\n    store.ctx.events.currentModeRender(featureInternal, (geojson) => {\n      store.sources[source].push(geojson);\n    });\n  }\n\n  if (coldChanged) {\n    store.ctx.map.getSource(Constants.sources.COLD).setData({\n      type: Constants.geojsonTypes.FEATURE_COLLECTION,\n      features: store.sources.cold\n    });\n  }\n\n  store.ctx.map.getSource(Constants.sources.HOT).setData({\n    type: Constants.geojsonTypes.FEATURE_COLLECTION,\n    features: store.sources.hot\n  });\n\n  if (store._emitSelectionChange) {\n    store.ctx.map.fire(Constants.events.SELECTION_CHANGE, {\n      features: store.getSelected().map(feature => feature.toGeoJSON())\n    });\n    store._emitSelectionChange = false;\n  }\n\n  if (store._deletedFeaturesToEmit.length) {\n    const geojsonToEmit = store._deletedFeaturesToEmit.map(feature => feature.toGeoJSON());\n\n    store._deletedFeaturesToEmit = [];\n\n    store.ctx.map.fire(Constants.events.DELETE, {\n      features: geojsonToEmit\n    });\n  }\n\n  store.ctx.map.fire(Constants.events.RENDER, {});\n  cleanup();\n\n  function cleanup() {\n    store.isDirty = false;\n    store.clearChangedIds();\n  }\n};\n"]},"metadata":{},"sourceType":"script"}